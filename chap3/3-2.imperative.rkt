#lang sicp
(define (factorial n)
  (let ((product 1)
        (counter 1))
    (define (iter)
      (if (> counter n)
          product
          (begin (set! product (* counter product))
                 (set! counter (+ counter 1))
                 (iter))))
    (iter)))

(define (visited-list)
  (let ((visited-pairs '()))
    (define (visit? p)
      (memq p visited-pairs))
    (define (add-pairs p)
      (set! visited-pairs (cons p visited-pairs)))
    (define (dispatch m)
      (cond ((eq? m 'add) add-pairs)
            ((eq? m 'visit?) visit?)
            (else (error "not valid message"))))
    dispatch))

;3.17 implementation
(define (count-pairs x)
  (let ((v (visited-list)))
    (define (iter current)
      (if (or (not (pair? current)) ((v 'visit?) current))
          0
          (begin ((v 'add) current)
                 (+ 1
                    (iter (car current))
                    (iter (cdr current))))))
    (iter x)))

(define (cycle? x)
  (let ((v (visited-list)))
    (define (iter current)
      (if (not (pair? current))
          #f
          (if ((v 'visit?) current)
              #t
              (begin ((v 'add) current)
                     (iter (cdr current))))))
    (iter x)))

(define (cycle-eff x)
  (define (safe-cddr x)
    (if (pair? (cdr x))
        (cddr x)
        '()))
  (define (safe-cdr x)
    (if (pair? x)
        (cdr x)
        '()))
  (define (iter tortoise hare)
    (cond ((null? tortoise) #f)
          ((null? hare) #f)
          ((eq? tortoise hare) #t)
          (else (iter (safe-cdr tortoise) (safe-cddr hare)))))
  (iter (safe-cdr x) (safe-cddr x)))


(define p1 (cons 'a '()))
(define p2 (cons 'b '()))
(define p3 (cons 'c '()))
(set-cdr! p2 p3)
(set-cdr! p1 p2)

(define t1 '(a))
(set-cdr! t1 t1)
(count-pairs p1)
(cycle? p1)
(cycle-eff p1)
(cycle-eff t1)
(cycle? t1)